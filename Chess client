from fltk import *
from funcs import img_resize
import sys, socket
import pickle


	
class Board(Fl_Double_Window):
	game=[] #locations of pieces on all boards 
	locs={} #locations of pieces on the current board, key=piece type, value=location
	running=False #clock is running
	pieces=[] #list of pieces
	images=[] #list of resized images
	kings=[] #used for win condition
	coords=[] #coords you send to other player 
	def __init__(self,x,y,w,h,label=None):
		super().__init__(x,y,w,h,label)
		
		self.sec=0 #first number on the clock
		self.tens=0 #second number on the clock
		self.min=3 #third number on the clock
		self.time=0 #time shown
		
		
		pngs=['rook2.png','knight2.png','bishop2.png','queen2.png','king2.png','pawn2.png','rook.png','knight.png','bishop.png','queen.png','king.png','pawn.png']
		
		for name in pngs: 
			if pngs.index(name) >= 6:
				Board.images.append(img_resize(name, 100)) #resizes black piece images
				
			else:
				Board.images.append(img_resize(name, 100)) #resizes white piece images
		
		self.begin()
		self.width=100
		
		self.label('CLIENT')
		self.undo=Fl_Button(800,0,200,100,'Undo')
		self.undo.callback(self.undocb)
		self.clock=Fl_Button(800,100,200,100, '3:00')
		self.clock.labelsize(80)
		self.clock.box(FL_DOWN_BOX)
		self.clock.color(FL_WHITE)
		self.clock.callback(self.butcb)
		self.conbut=Fl_Button(800,200,200,100, 'Connect')
		self.conbut.callback(self.conbutcb)
		
		self.bl=[]
		
		for y in range(8):
			self.xcord=[]
			for x in range(8):
				self.but=Fl_Button(x*self.width, y*self.width, self.width,self.width)
				self.but.box(FL_FLAT_BOX)
				self.xcord.append(self.but)
				if y%2==0:
					if x%2==0:
						self.but.color(55,47) 
					else:
						self.but.color(229,179)
					
				if y%2==1:	
					if x%2==1:
						self.but.color(55,47)
					else:
						self.but.color(229,179)	
				
				
			self.bl.append(self.xcord)
			
		'''PAWNS'''
		
		for col in range(8):
			Board.pieces.append(Piece(Board.images[5], col*100, 600, 100, 100))
			
			
		for col in range(8):
			Board.pieces.append(Piece(Board.images[11], col*100, 100, 100, 100))	
			
		
		'ROOKS'''
			
		Board.pieces.append(Piece(Board.images[0], 0, 700, 100,100))
		Board.pieces.append(Piece(Board.images[0], 700, 700, 100,100))
		Board.pieces.append(Piece(Board.images[6], 0, 0, 100,100))
		Board.pieces.append(Piece(Board.images[6], 700, 0, 100,100))
		
		
		'''BISHOPS'''
		Board.pieces.append(Piece(Board.images[2], 200, 700, 100,100))
		Board.pieces.append(Piece(Board.images[2], 500, 700, 100,100))
		Board.pieces.append(Piece(Board.images[8], 200, 0, 100,100))
		Board.pieces.append(Piece(Board.images[8], 500, 0, 100,100))
		
		
		'''KINGS'''
		Board.kings.append(Piece(Board.images[4], 400, 700, 100, 100))
		Board.kings.append(Piece(Board.images[10], 400, 0, 100, 100))
		
		
		'''QUEENS'''
		Board.pieces.append(Piece(Board.images[3], 300, 700, 100, 100))
		Board.pieces.append(Piece(Board.images[9], 300, 0, 100, 100))
		
		
		'''KNIGHTS'''
		Board.pieces.append(Piece(Board.images[1], 100, 700, 100, 100))
		Board.pieces.append(Piece(Board.images[1], 600, 700, 100, 100))
		Board.pieces.append(Piece(Board.images[7], 100, 0, 100, 100))
		Board.pieces.append(Piece(Board.images[7], 600, 0, 100, 100))
			
		self.end()
		
		
		
		self.show()
	
	def conbutcb(self, wid):
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		host = 'localhost'
		port = 4444
		s.connect( (host, port) )
		for x in Board.game[-1].values():
			Board.coords.append(x)
		
		data = pickle.dumps(Board.coords)
		s.sendall(data)
		
	def receive_data(self):
		try:
			L2= pickle.loads(s.recv(1024))
			Board.game.append(L2)
			print('Server sends modified list:')
			print(Board.game)
		except pickle.UnpicklingError:
			print('Error: 1024 bytes read buffer is too small. Increase buffer size')
		finally:
			s.close()
		
	def butcb(self, wid):
		if Board.running==True:
			Board.running=False
		else:
			Board.running=True
			self.timer()
	
	def undocb(self, wid):
		
		if len(Board.game) > 1:
			for piece, loc in Board.game[-1].items():
				piece.position(loc[0],loc[1])
				Board.locs[piece]=(loc[0],loc[1])
				
				
				if piece in Piece.taken:
					piece.show()
					Piece.taken.pop(piece)
			
			Board.game.append(dict(Board.locs.items()))	
			
			
		self.redraw()
				
	
	
		
	'''TIMER FUNCTION'''
	def timer(self):
		if Board.running==True:
			self.time=(f'{self.min}:{self.tens}{self.sec}')
			self.clock.label(f'{self.time}')
			
			self.sec=self.sec-1
			
			if self.sec < 0:
				self.tens=self.tens-1
				self.sec=9
				
			if self.tens < 0:
				self.tens=5
				self.min-=1
				
			if self.min == 0 and self.tens == 0 and self.sec == 0:
				self.clock.label(f'Time: {0:00}')
				Board.running=False
				fl_message('You lose!')
			
			Fl.add_timeout(1, self.timer)
		
		

class Piece(Fl_Box):
	taken={}
	def __init__(self,pic, x, y, w, h):
		super().__init__(x, y, w, h)
		self.box(FL_NO_BOX) # default: box is not drawn
		self.image(pic)
		Board.locs[self]=(x,y)
		self.cx=self.x()
		self.cy=self.y()
		if len(Board.locs) == 32:
			Board.game.append(dict(Board.locs.items()))

	def handle(self, event):
		r = super().handle(event)
		
		if event==FL_PUSH:
			self.dx= Fl.event_x() - self.x()
			self.dy= Fl.event_y() - self.y()
			return 1
		elif event==FL_DRAG:
			X= Fl.event_x()
			Y= Fl.event_y()
			self.position(X-self.dx, Y-self.dy)
			self.parent().redraw()
			return 1
		elif event==FL_RELEASE:
			self.marked=[]
			X= Fl.event_x()
			Y= Fl.event_y()
			self.position(X//100*100,Y//100*100)
			if Board.running==True:
				
				
				
				if (X//100*100,Y//100*100)!=(self.cx,self.cy):
					Board.game.append(dict(Board.locs.items()))
					
					if X//100*100 < 0 or X//100*100 > 700 or Y//100*100 < 0 or Y//100*100 > 700:
						X=Board.locs[self][0]
						Y=Board.locs[self][1]
						self.position(X,Y)
						
						
					
					if (X//100*100,Y//100*100) in Board.locs.values():
						for piece, loc in Board.locs.items():
							if loc == (X//100*100,Y//100*100):
								if piece in Board.kings:
									fl_message('game over')
									Board.running=False
									
									
								Piece.taken[piece]=piece.image()
								self.marked.append(piece)
								piece.hide()
								
								
						Board.locs.pop(self.marked[-1])
					
							
					Board.locs[self]=(X//100*100,Y//100*100)
								
					self.cx=X//100*100
					self.cy=Y//100*100			
			else:
				self.position(self.cx,self.cy)				
				
			self.parent().redraw()
			

			return 1
		else:
			return r

	
x=Fl.w()//2-400
y=Fl.h()//2-400	
w=1000
h=800		

game=Board(x,y,w,h)

Fl_scheme('gltk+')



Fl.run()
